---
id: "typescript-best-practices"
title: "TypeScriptå‹å®‰å…¨é–‹ç™ºã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹"
description: "Next.jsãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§TypeScriptã‚’åŠ¹æœçš„ã«æ´»ç”¨ã—ã€å‹å®‰å…¨ã§ä¿å®ˆæ€§ã®é«˜ã„ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ããŸã‚ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’è©³ã—ãè§£èª¬ã—ã¾ã™ã€‚"
date: "2025-01-18"
category: "TypeScript"
tags: ["TypeScript", "Type Safety", "Next.js", "Development", "Best Practices"]
author: "Developer"
image: "/images/blog/typescript-best-practices.jpg"
featured: true
published: true
readingTime: 13
---

# TypeScriptå‹å®‰å…¨é–‹ç™ºã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

TypeScriptã¯å˜ãªã‚‹JavaScriptã®æ‹¡å¼µã§ã¯ãªãã€å¤§è¦æ¨¡ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹ç™ºã«ãŠã‘ã‚‹å“è³ªã¨ä¿å®ˆæ€§ã‚’å¤§å¹…ã«å‘ä¸Šã•ã›ã‚‹å¼·åŠ›ãªãƒ„ãƒ¼ãƒ«ã§ã™ã€‚æœ¬è¨˜äº‹ã§ã¯ã€Next.jsãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§TypeScriptã‚’åŠ¹æœçš„ã«æ´»ç”¨ã™ã‚‹ãŸã‚ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’è©³ã—ãè§£èª¬ã—ã¾ã™ã€‚

## ğŸ¯ å‹å®‰å…¨æ€§ãŒã‚‚ãŸã‚‰ã™ãƒ¡ãƒªãƒƒãƒˆ

### é–‹ç™ºåŠ¹ç‡ã®å‘ä¸Š
- **æ—©æœŸã‚¨ãƒ©ãƒ¼ç™ºè¦‹**: ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ãƒã‚°ã‚’æ¤œå‡º
- **ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°æ”¯æ´**: å½±éŸ¿ç¯„å›²ã®å¯è¦–åŒ–
- **ã‚¤ãƒ³ãƒ†ãƒªã‚»ãƒ³ã‚¹**: ã‚¨ãƒ‡ã‚£ã‚¿ã§ã®è‡ªå‹•è£œå®Œã¨ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆè¡¨ç¤º
- **ãƒãƒ¼ãƒ é–‹ç™º**: ã‚³ãƒ¼ãƒ‰ã®æ„å›³ãŒæ˜ç¢ºã«ãªã‚‹

### ä¿å®ˆæ€§ã®å‘ä¸Š
- **è‡ªå·±æ–‡æ›¸åŒ–**: å‹å®šç¾©ãŒãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®å½¹å‰²
- **ç ´å£Šçš„å¤‰æ›´ã®é˜²æ­¢**: APIã®å¤‰æ›´æ™‚ã«å½±éŸ¿ç®‡æ‰€ã‚’ç‰¹å®š
- **ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼**: å‹ã«ã‚ˆã‚‹åˆ¶ç´„ã§å“è³ªå‘ä¸Š

## ğŸ› ï¸ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®šã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### 1. tsconfig.jsonã®æœ€é©åŒ–

```json
{
  "compilerOptions": {
    // åŸºæœ¬è¨­å®š
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "lib": ["DOM", "DOM.Iterable", "ES6"],
    
    // å‹ãƒã‚§ãƒƒã‚¯è¨­å®šï¼ˆæœ€ã‚‚å³æ ¼ã«ï¼‰
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,
    
    // è¿½åŠ ã®ãƒã‚§ãƒƒã‚¯
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitOverride": true,
    "allowUnusedLabels": false,
    "allowUnreachableCode": false,
    
    // è§£æ±ºã¨ãƒ‘ã‚¹
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@/components/*": ["./src/components/*"],
      "@/lib/*": ["./src/lib/*"],
      "@/types/*": ["./src/types/*"],
      "@/utils/*": ["./src/utils/*"]
    },
    
    // Next.jsé–¢é€£
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "incremental": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    ".next",
    "out"
  ]
}
```

### 2. ESLintã¨ã®é€£æº

```json
// .eslintrc.json
{
  "extends": [
    "next/core-web-vitals",
    "@typescript-eslint/recommended",
    "@typescript-eslint/recommended-requiring-type-checking"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "project": "./tsconfig.json"
  },
  "rules": {
    // TypeScriptå›ºæœ‰ã®ãƒ«ãƒ¼ãƒ«
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/prefer-const": "error",
    "@typescript-eslint/no-non-null-assertion": "warn",
    "@typescript-eslint/explicit-function-return-type": "off",
    "@typescript-eslint/explicit-module-boundary-types": "off",
    
    // ã‚ˆã‚Šå³æ ¼ãªãƒ«ãƒ¼ãƒ«
    "@typescript-eslint/no-floating-promises": "error",
    "@typescript-eslint/await-thenable": "error",
    "@typescript-eslint/no-misused-promises": "error",
    "@typescript-eslint/require-await": "error",
    
    // ã‚³ãƒ¼ãƒ‰ã‚¹ã‚¿ã‚¤ãƒ«
    "@typescript-eslint/consistent-type-imports": [
      "error",
      { "prefer": "type-imports" }
    ],
    "@typescript-eslint/consistent-type-definitions": ["error", "interface"]
  }
}
```

## ğŸ—ï¸ å‹å®šç¾©ã®è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³

### 1. ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«ã®å‹å®šç¾©

```typescript
// types/domain.ts

// åŸºæœ¬çš„ãªãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã®æ‹¡å¼µ
export type ID = string & { readonly brand: unique symbol };
export type Email = string & { readonly brand: unique symbol };
export type URL = string & { readonly brand: unique symbol };
export type ISODate = string & { readonly brand: unique symbol };

// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
export const createID = (value: string): ID => value as ID;
export const createEmail = (value: string): Email => {
  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
    throw new Error('Invalid email format');
  }
  return value as Email;
};

// ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‰ãƒ¡ã‚¤ãƒ³
export interface User {
  readonly id: ID;
  readonly email: Email;
  readonly name: string;
  readonly avatar?: URL;
  readonly createdAt: ISODate;
  readonly updatedAt: ISODate;
  readonly role: UserRole;
  readonly profile: UserProfile;
}

export type UserRole = 'admin' | 'editor' | 'viewer';

export interface UserProfile {
  readonly bio?: string;
  readonly website?: URL;
  readonly location?: string;
  readonly socialLinks: SocialLinks;
}

export interface SocialLinks {
  readonly twitter?: string;
  readonly github?: string;
  readonly linkedin?: string;
}

// ãƒ–ãƒ­ã‚°ãƒ‰ãƒ¡ã‚¤ãƒ³
export interface BlogPost {
  readonly id: ID;
  readonly slug: string;
  readonly title: string;
  readonly description: string;
  readonly content: string;
  readonly author: User;
  readonly category: Category;
  readonly tags: readonly Tag[];
  readonly featured: boolean;
  readonly published: boolean;
  readonly publishedAt?: ISODate;
  readonly createdAt: ISODate;
  readonly updatedAt: ISODate;
  readonly metadata: PostMetadata;
  readonly analytics: PostAnalytics;
}

export interface PostMetadata {
  readonly readingTime: number;
  readonly wordCount: number;
  readonly language: string;
  readonly seo: SEOMetadata;
}

export interface SEOMetadata {
  readonly metaTitle?: string;
  readonly metaDescription?: string;
  readonly canonicalUrl?: URL;
  readonly ogImage?: URL;
  readonly keywords: readonly string[];
}

export interface PostAnalytics {
  readonly views: number;
  readonly likes: number;
  readonly shares: number;
  readonly comments: number;
}

export interface Category {
  readonly id: ID;
  readonly name: string;
  readonly slug: string;
  readonly description?: string;
  readonly color?: string;
}

export interface Tag {
  readonly id: ID;
  readonly name: string;
  readonly slug: string;
}
```

### 2. API Responseå‹ã®å®šç¾©

```typescript
// types/api.ts

// åŸºæœ¬çš„ãªAPI Responseæ§‹é€ 
export interface ApiResponse<T> {
  readonly success: boolean;
  readonly data?: T;
  readonly error?: ApiError;
  readonly meta?: ResponseMeta;
}

export interface ApiError {
  readonly code: string;
  readonly message: string;
  readonly details?: Record<string, unknown>;
}

export interface ResponseMeta {
  readonly timestamp: ISODate;
  readonly requestId: string;
  readonly version: string;
}

// ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³
export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  readonly pagination: PaginationMeta;
}

export interface PaginationMeta {
  readonly currentPage: number;
  readonly totalPages: number;
  readonly totalItems: number;
  readonly itemsPerPage: number;
  readonly hasNextPage: boolean;
  readonly hasPreviousPage: boolean;
}

// å…·ä½“çš„ãªAPI Responseå‹
export type GetBlogPostsResponse = PaginatedResponse<BlogPost>;
export type GetBlogPostResponse = ApiResponse<BlogPost>;
export type CreateBlogPostResponse = ApiResponse<BlogPost>;
export type UpdateBlogPostResponse = ApiResponse<BlogPost>;
export type DeleteBlogPostResponse = ApiResponse<{ deleted: boolean }>;

// Requestå‹
export interface CreateBlogPostRequest {
  readonly title: string;
  readonly description: string;
  readonly content: string;
  readonly categoryId: ID;
  readonly tagIds: readonly ID[];
  readonly featured?: boolean;
  readonly published?: boolean;
}

export interface UpdateBlogPostRequest extends Partial<CreateBlogPostRequest> {
  readonly id: ID;
}

export interface GetBlogPostsRequest {
  readonly page?: number;
  readonly limit?: number;
  readonly category?: string;
  readonly tags?: readonly string[];
  readonly featured?: boolean;
  readonly published?: boolean;
  readonly search?: string;
  readonly sortBy?: 'createdAt' | 'updatedAt' | 'title' | 'views';
  readonly sortOrder?: 'asc' | 'desc';
}
```

### 3. Component Propså‹ã®å®šç¾©

```typescript
// types/components.ts

// åŸºæœ¬çš„ãªã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆProps
export interface BaseComponentProps {
  readonly className?: string;
  readonly children?: React.ReactNode;
  readonly testId?: string;
}

// ãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
export interface ButtonProps extends BaseComponentProps {
  readonly variant?: 'primary' | 'secondary' | 'outline' | 'ghost' | 'destructive';
  readonly size?: 'sm' | 'md' | 'lg' | 'icon';
  readonly disabled?: boolean;
  readonly loading?: boolean;
  readonly leftIcon?: React.ReactNode;
  readonly rightIcon?: React.ReactNode;
  readonly onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
  readonly type?: 'button' | 'submit' | 'reset';
  readonly asChild?: boolean;
}

// ãƒ–ãƒ­ã‚°ã‚«ãƒ¼ãƒ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
export interface BlogCardProps extends BaseComponentProps {
  readonly post: BlogPost;
  readonly variant?: 'default' | 'compact' | 'featured';
  readonly showExcerpt?: boolean;
  readonly showAuthor?: boolean;
  readonly showDate?: boolean;
  readonly showTags?: boolean;
  readonly showReadingTime?: boolean;
  readonly onTagClick?: (tag: Tag) => void;
}

// ãƒ•ã‚©ãƒ¼ãƒ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
export interface FormFieldProps<T = unknown> extends BaseComponentProps {
  readonly name: string;
  readonly label?: string;
  readonly placeholder?: string;
  readonly required?: boolean;
  readonly disabled?: boolean;
  readonly error?: string;
  readonly helperText?: string;
  readonly value?: T;
  readonly onChange?: (value: T) => void;
  readonly onBlur?: () => void;
}

export interface TextFieldProps extends FormFieldProps<string> {
  readonly type?: 'text' | 'email' | 'password' | 'url' | 'tel';
  readonly multiline?: boolean;
  readonly rows?: number;
  readonly maxLength?: number;
  readonly pattern?: string;
}

export interface SelectFieldProps<T = string> extends FormFieldProps<T> {
  readonly options: readonly SelectOption<T>[];
  readonly multiple?: boolean;
  readonly searchable?: boolean;
}

export interface SelectOption<T = string> {
  readonly value: T;
  readonly label: string;
  readonly disabled?: boolean;
  readonly group?: string;
}
```

## ğŸ”§ å®Ÿç”¨çš„ãªTypeScriptå®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³

### 1. å‹å®‰å…¨ãªAPI Client

```typescript
// lib/api-client.ts
import type { 
  ApiResponse, 
  GetBlogPostsResponse,
  GetBlogPostResponse,
  CreateBlogPostRequest,
  CreateBlogPostResponse,
  UpdateBlogPostRequest,
  UpdateBlogPostResponse 
} from '@/types/api';

class ApiClient {
  private baseUrl: string;
  
  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<ApiResponse<T>> {
    const url = `${this.baseUrl}${endpoint}`;
    
    const response = await fetch(url, {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
      ...options,
    });

    if (!response.ok) {
      throw new Error(`API Error: ${response.status} ${response.statusText}`);
    }

    return response.json() as Promise<ApiResponse<T>>;
  }

  // å‹å®‰å…¨ãªãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©
  async getBlogPosts(params?: GetBlogPostsRequest): Promise<GetBlogPostsResponse> {
    const searchParams = new URLSearchParams();
    
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined) {
          if (Array.isArray(value)) {
            value.forEach(v => searchParams.append(key, String(v)));
          } else {
            searchParams.append(key, String(value));
          }
        }
      });
    }

    const query = searchParams.toString();
    const endpoint = `/api/blog${query ? `?${query}` : ''}`;
    
    return this.request<BlogPost[]>(endpoint);
  }

  async getBlogPost(slug: string): Promise<GetBlogPostResponse> {
    return this.request<BlogPost>(`/api/blog/${slug}`);
  }

  async createBlogPost(data: CreateBlogPostRequest): Promise<CreateBlogPostResponse> {
    return this.request<BlogPost>('/api/blog', {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  async updateBlogPost(data: UpdateBlogPostRequest): Promise<UpdateBlogPostResponse> {
    return this.request<BlogPost>(`/api/blog/${data.id}`, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  }
}

export const apiClient = new ApiClient(process.env.NEXT_PUBLIC_API_URL || '');
```

### 2. å‹å®‰å…¨ãªHooks

```typescript
// hooks/use-blog-posts.ts
import { useState, useEffect, useCallback } from 'react';
import type { BlogPost, GetBlogPostsRequest } from '@/types';
import { apiClient } from '@/lib/api-client';

interface UseBlogPostsState {
  posts: BlogPost[];
  loading: boolean;
  error: string | null;
  hasNextPage: boolean;
  totalCount: number;
}

interface UseBlogPostsActions {
  refresh: () => Promise<void>;
  loadMore: () => Promise<void>;
  setFilters: (filters: Partial<GetBlogPostsRequest>) => void;
}

export function useBlogPosts(
  initialFilters: GetBlogPostsRequest = {}
): UseBlogPostsState & UseBlogPostsActions {
  const [state, setState] = useState<UseBlogPostsState>({
    posts: [],
    loading: true,
    error: null,
    hasNextPage: false,
    totalCount: 0,
  });
  
  const [filters, setFilters] = useState<GetBlogPostsRequest>(initialFilters);

  const fetchPosts = useCallback(async (reset = false) => {
    try {
      setState(prev => ({ ...prev, loading: true, error: null }));
      
      const params: GetBlogPostsRequest = {
        ...filters,
        page: reset ? 1 : (filters.page || 1),
      };

      const response = await apiClient.getBlogPosts(params);
      
      if (response.success && response.data) {
        setState(prev => ({
          ...prev,
          posts: reset ? response.data! : [...prev.posts, ...response.data!],
          hasNextPage: response.pagination?.hasNextPage || false,
          totalCount: response.pagination?.totalItems || 0,
          loading: false,
        }));
      } else {
        setState(prev => ({
          ...prev,
          error: response.error?.message || 'Failed to fetch posts',
          loading: false,
        }));
      }
    } catch (error) {
      setState(prev => ({
        ...prev,
        error: error instanceof Error ? error.message : 'Unknown error',
        loading: false,
      }));
    }
  }, [filters]);

  const refresh = useCallback(() => fetchPosts(true), [fetchPosts]);
  
  const loadMore = useCallback(async () => {
    if (!state.loading && state.hasNextPage) {
      setFilters(prev => ({ ...prev, page: (prev.page || 1) + 1 }));
    }
  }, [state.loading, state.hasNextPage]);

  const updateFilters = useCallback((newFilters: Partial<GetBlogPostsRequest>) => {
    setFilters(prev => ({ ...prev, ...newFilters, page: 1 }));
  }, []);

  useEffect(() => {
    fetchPosts(true);
  }, [fetchPosts]);

  return {
    ...state,
    refresh,
    loadMore,
    setFilters: updateFilters,
  };
}
```

### 3. å‹å®‰å…¨ãªFormç®¡ç†

```typescript
// hooks/use-form.ts
import { useState, useCallback } from 'react';

type ValidationRule<T> = (value: T) => string | null;

interface FormField<T> {
  value: T;
  error: string | null;
  touched: boolean;
  validationRules: ValidationRule<T>[];
}

type FormState<T extends Record<string, any>> = {
  [K in keyof T]: FormField<T[K]>;
};

interface UseFormOptions<T> {
  initialValues: T;
  validationRules?: Partial<Record<keyof T, ValidationRule<T[keyof T]>[]>>;
  onSubmit?: (values: T) => Promise<void> | void;
}

export function useForm<T extends Record<string, any>>({
  initialValues,
  validationRules = {},
  onSubmit,
}: UseFormOptions<T>) {
  const [formState, setFormState] = useState<FormState<T>>(() => {
    const initialState: Partial<FormState<T>> = {};
    
    Object.keys(initialValues).forEach(key => {
      const fieldKey = key as keyof T;
      initialState[fieldKey] = {
        value: initialValues[fieldKey],
        error: null,
        touched: false,
        validationRules: validationRules[fieldKey] || [],
      } as FormField<T[keyof T]>;
    });
    
    return initialState as FormState<T>;
  });

  const [isSubmitting, setIsSubmitting] = useState(false);

  const validateField = useCallback(<K extends keyof T>(
    name: K,
    value: T[K]
  ): string | null => {
    const field = formState[name];
    
    for (const rule of field.validationRules) {
      const error = rule(value);
      if (error) return error;
    }
    
    return null;
  }, [formState]);

  const setFieldValue = useCallback(<K extends keyof T>(
    name: K,
    value: T[K]
  ) => {
    const error = validateField(name, value);
    
    setFormState(prev => ({
      ...prev,
      [name]: {
        ...prev[name],
        value,
        error,
        touched: true,
      },
    }));
  }, [validateField]);

  const setFieldError = useCallback(<K extends keyof T>(
    name: K,
    error: string | null
  ) => {
    setFormState(prev => ({
      ...prev,
      [name]: {
        ...prev[name],
        error,
      },
    }));
  }, []);

  const getFieldProps = useCallback(<K extends keyof T>(name: K) => ({
    value: formState[name].value,
    error: formState[name].touched ? formState[name].error : null,
    onChange: (value: T[K]) => setFieldValue(name, value),
    onBlur: () => {
      setFormState(prev => ({
        ...prev,
        [name]: {
          ...prev[name],
          touched: true,
        },
      }));
    },
  }), [formState, setFieldValue]);

  const validate = useCallback((): boolean => {
    let isValid = true;
    const newFormState = { ...formState };

    Object.keys(formState).forEach(key => {
      const fieldKey = key as keyof T;
      const field = formState[fieldKey];
      const error = validateField(fieldKey, field.value);
      
      newFormState[fieldKey] = {
        ...field,
        error,
        touched: true,
      };
      
      if (error) isValid = false;
    });

    setFormState(newFormState);
    return isValid;
  }, [formState, validateField]);

  const handleSubmit = useCallback(async (event?: React.FormEvent) => {
    event?.preventDefault();
    
    if (!validate() || !onSubmit) return;
    
    setIsSubmitting(true);
    
    try {
      const values = Object.keys(formState).reduce((acc, key) => {
        acc[key as keyof T] = formState[key as keyof T].value;
        return acc;
      }, {} as T);
      
      await onSubmit(values);
    } catch (error) {
      console.error('Form submission error:', error);
    } finally {
      setIsSubmitting(false);
    }
  }, [formState, validate, onSubmit]);

  const reset = useCallback(() => {
    setFormState(prev => {
      const resetState: Partial<FormState<T>> = {};
      
      Object.keys(prev).forEach(key => {
        const fieldKey = key as keyof T;
        resetState[fieldKey] = {
          ...prev[fieldKey],
          value: initialValues[fieldKey],
          error: null,
          touched: false,
        };
      });
      
      return resetState as FormState<T>;
    });
  }, [initialValues]);

  const values = Object.keys(formState).reduce((acc, key) => {
    acc[key as keyof T] = formState[key as keyof T].value;
    return acc;
  }, {} as T);

  const errors = Object.keys(formState).reduce((acc, key) => {
    const fieldKey = key as keyof T;
    const field = formState[fieldKey];
    if (field.touched && field.error) {
      acc[fieldKey] = field.error;
    }
    return acc;
  }, {} as Partial<Record<keyof T, string>>);

  const isValid = Object.values(errors).length === 0;
  const isDirty = Object.values(formState).some(field => field.touched);

  return {
    values,
    errors,
    isValid,
    isDirty,
    isSubmitting,
    setFieldValue,
    setFieldError,
    getFieldProps,
    handleSubmit,
    validate,
    reset,
  };
}
```

## ğŸ§ª å‹å®‰å…¨ãªãƒ†ã‚¹ãƒˆ

### 1. TypeScriptã§ã®ãƒ†ã‚¹ãƒˆãƒ˜ãƒ«ãƒ‘ãƒ¼

```typescript
// test-utils/type-safe-testing.ts
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import type { ComponentProps } from 'react';

// ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®Propså‹ã‚’è‡ªå‹•ã§æ¨è«–ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
export function createComponentTester<T extends React.ComponentType<any>>(
  Component: T
) {
  return {
    render: (props: ComponentProps<T>) => render(<Component {...props} />),
    
    // å‹å®‰å…¨ãªãƒ—ãƒ­ãƒƒãƒ—ã‚¹ä½œæˆ
    createProps: (overrides: Partial<ComponentProps<T>> = {}): ComponentProps<T> => ({
      ...getDefaultProps(Component),
      ...overrides,
    }),
  };
}

// ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã®å‹å®‰å…¨ãªä½œæˆ
export function createMockData<T>(factory: () => T): T {
  return factory();
}

// ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
export const testDataFactories = {
  blogPost: (): BlogPost => ({
    id: createID('test-post-1'),
    slug: 'test-post',
    title: 'Test Blog Post',
    description: 'This is a test blog post',
    content: '# Test Content\n\nThis is test content.',
    author: testDataFactories.user(),
    category: testDataFactories.category(),
    tags: [testDataFactories.tag()],
    featured: false,
    published: true,
    publishedAt: '2024-01-15' as ISODate,
    createdAt: '2024-01-15' as ISODate,
    updatedAt: '2024-01-15' as ISODate,
    metadata: {
      readingTime: 5,
      wordCount: 100,
      language: 'ja',
      seo: {
        keywords: ['test', 'blog'],
      },
    },
    analytics: {
      views: 0,
      likes: 0,
      shares: 0,
      comments: 0,
    },
  }),

  user: (): User => ({
    id: createID('test-user-1'),
    email: createEmail('test@example.com'),
    name: 'Test User',
    createdAt: '2024-01-15' as ISODate,
    updatedAt: '2024-01-15' as ISODate,
    role: 'editor',
    profile: {
      socialLinks: {},
    },
  }),

  category: (): Category => ({
    id: createID('test-category-1'),
    name: 'Test Category',
    slug: 'test-category',
  }),

  tag: (): Tag => ({
    id: createID('test-tag-1'),
    name: 'Test Tag',
    slug: 'test-tag',
  }),
};
```

### 2. å‹å®‰å…¨ãªãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹

```typescript
// components/blog-card.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { createComponentTester, testDataFactories } from '@/test-utils';
import { BlogCard } from './blog-card';

const { render, createProps } = createComponentTester(BlogCard);

describe('BlogCard', () => {
  it('renders blog post information correctly', () => {
    const mockPost = testDataFactories.blogPost();
    const props = createProps({ post: mockPost });
    
    render(props);
    
    expect(screen.getByText(mockPost.title)).toBeInTheDocument();
    expect(screen.getByText(mockPost.description)).toBeInTheDocument();
    expect(screen.getByText(mockPost.author.name)).toBeInTheDocument();
  });

  it('calls onTagClick when tag is clicked', async () => {
    const user = userEvent.setup();
    const mockPost = testDataFactories.blogPost();
    const mockOnTagClick = vi.fn();
    
    const props = createProps({ 
      post: mockPost, 
      onTagClick: mockOnTagClick 
    });
    
    render(props);
    
    const tagButton = screen.getByText(mockPost.tags[0].name);
    await user.click(tagButton);
    
    expect(mockOnTagClick).toHaveBeenCalledWith(mockPost.tags[0]);
  });

  it('shows reading time when enabled', () => {
    const mockPost = testDataFactories.blogPost();
    const props = createProps({ 
      post: mockPost, 
      showReadingTime: true 
    });
    
    render(props);
    
    expect(screen.getByText(`${mockPost.metadata.readingTime}åˆ†ã§èª­ã‚ã¾ã™`))
      .toBeInTheDocument();
  });
});
```

## ğŸ” é«˜åº¦ãªå‹ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯

### 1. Utility Typesã®æ´»ç”¨

```typescript
// types/utilities.ts

// ç‰¹å®šã®ã‚­ãƒ¼ã®ã¿ã‚’å¿…é ˆã«ã™ã‚‹
export type RequireFields<T, K extends keyof T> = T & Required<Pick<T, K>>;

// ç‰¹å®šã®ã‚­ãƒ¼ã‚’ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ã«ã™ã‚‹
export type OptionalFields<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

// ãƒã‚¹ãƒˆã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‘ã‚¹ã‚’å‹å®‰å…¨ã«å–å¾—
export type NestedKeyOf<T extends Record<string, any>> = {
  [K in keyof T & (string | number)]: T[K] extends Record<string, any>
    ? `${K}` | `${K}.${NestedKeyOf<T[K]>}`
    : `${K}`;
}[keyof T & (string | number)];

// é…åˆ—ã®è¦ç´ å‹ã‚’å–å¾—
export type ArrayElement<T> = T extends readonly (infer U)[] ? U : never;

// é–¢æ•°ã®æˆ»ã‚Šå€¤å‹ã‚’å–å¾—ï¼ˆPromiseå¯¾å¿œï¼‰
export type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;

// ä½¿ç”¨ä¾‹
type BlogPostFields = RequireFields<BlogPost, 'title' | 'content'>;
type CreatePostData = OptionalFields<BlogPost, 'id' | 'createdAt' | 'updatedAt'>;
type PostPath = NestedKeyOf<BlogPost>; // 'title' | 'author.name' | 'metadata.seo.keywords' ãªã©
type TagType = ArrayElement<BlogPost['tags']>; // Tagå‹
```

### 2. æ¡ä»¶ä»˜ãå‹ã®æ´»ç”¨

```typescript
// types/conditional.ts

// APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å‹ã‚’å‹•çš„ã«æ±ºå®š
export type ApiEndpoint = 'posts' | 'users' | 'categories';

export type ApiResponseType<T extends ApiEndpoint> = 
  T extends 'posts' ? BlogPost[] :
  T extends 'users' ? User[] :
  T extends 'categories' ? Category[] :
  never;

// ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®variantã«åŸºã¥ãå‹åˆ¶ç´„
export type ButtonVariant = 'primary' | 'secondary' | 'destructive';

export type ButtonPropsForVariant<V extends ButtonVariant> = 
  V extends 'destructive' 
    ? { confirmAction?: boolean; dangerText?: string }
    : { confirmAction?: never; dangerText?: never };

export interface ExtendedButtonProps<V extends ButtonVariant = 'primary'> 
  extends ButtonProps, ButtonPropsForVariant<V> {
  variant?: V;
}

// ãƒ•ã‚©ãƒ¼ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‹åˆ¶ç´„
export type FieldType = 'text' | 'email' | 'select' | 'checkbox';

export type FieldValueType<T extends FieldType> =
  T extends 'text' | 'email' ? string :
  T extends 'select' ? string | string[] :
  T extends 'checkbox' ? boolean :
  never;

export interface FormFieldProps<T extends FieldType> {
  type: T;
  value: FieldValueType<T>;
  onChange: (value: FieldValueType<T>) => void;
}
```

## ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### 1. å‹ãƒ¬ãƒ™ãƒ«ã§ã®æœ€é©åŒ–

```typescript
// lib/performance-types.ts

// é‡ã„è¨ˆç®—ã‚’å‹ãƒ¬ãƒ™ãƒ«ã§æœ€é©åŒ–
export interface CachedApiResponse<T> {
  data: T;
  timestamp: number;
  expiry: number;
}

// ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚­ãƒ¼ã®å‹å®‰å…¨ãªç”Ÿæˆ
export type CacheKey<T extends Record<string, any>> = {
  [K in keyof T]: T[K] extends string | number | boolean ? T[K] : string;
};

export function createCacheKey<T extends Record<string, any>>(
  params: CacheKey<T>
): string {
  return Object.entries(params)
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([key, value]) => `${key}:${value}`)
    .join('|');
}

// ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æœ€é©åŒ–ã®ãŸã‚ã®å‹
export interface MemoizedComponentProps {
  readonly [key: string]: any;
}

export function createMemoComponent<P extends MemoizedComponentProps>(
  Component: React.ComponentType<P>,
  areEqual?: (prevProps: P, nextProps: P) => boolean
): React.MemoExoticComponent<React.ComponentType<P>> {
  return React.memo(Component, areEqual);
}
```

### 2. ãƒãƒ³ãƒ‰ãƒ«ã‚µã‚¤ã‚ºæœ€é©åŒ–

```typescript
// å‹ã®ã¿ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆä½¿ç”¨
import type { BlogPost, User, Category } from '@/types';

// å‹•çš„ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ã‚³ãƒ¼ãƒ‰åˆ†å‰²
export const LazyBlogEditor = React.lazy(() => 
  import('./blog-editor').then(module => ({ 
    default: module.BlogEditor 
  }))
);

// æ¡ä»¶ä»˜ãã‚¤ãƒ³ãƒãƒ¼ãƒˆ
export async function loadChartLibrary() {
  if (typeof window === 'undefined') return null;
  
  const { Chart } = await import('chart.js');
  return Chart;
}
```

## ã¾ã¨ã‚

TypeScriptã‚’åŠ¹æœçš„ã«æ´»ç”¨ã™ã‚‹ã“ã¨ã§ã€å¤§è¦æ¨¡ãªNext.jsã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®é–‹ç™ºã¨ä¿å®ˆãŒåŠ‡çš„ã«æ”¹å–„ã•ã‚Œã¾ã™ã€‚é‡è¦ãªã®ã¯ã€å˜ã«å‹ã‚’ä»˜ã‘ã‚‹ã ã‘ã§ãªãã€ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ã‚’å‹ã§è¡¨ç¾ã—ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«å¤šãã®ã‚¨ãƒ©ãƒ¼ã‚’é˜²ãã“ã¨ã§ã™ã€‚

**æˆåŠŸã®ãƒã‚¤ãƒ³ãƒˆ:**
1. **æ®µéšçš„å°å…¥**: strict modeã‚’å¾ã€…ã«æœ‰åŠ¹åŒ–
2. **ãƒ‰ãƒ¡ã‚¤ãƒ³é‡è¦–**: ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚’å‹ã§è¡¨ç¾
3. **å‹å®‰å…¨ãªAPI**: ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰ã®å‹å®‰å…¨æ€§
4. **ãƒ†ã‚¹ãƒˆæ”¯æ´**: å‹ã‚’æ´»ç”¨ã—ãŸãƒ†ã‚¹ãƒˆãƒ˜ãƒ«ãƒ‘ãƒ¼
5. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: å‹ãƒ¬ãƒ™ãƒ«ã§ã®æœ€é©åŒ–

TypeScriptã¯å˜ãªã‚‹é–‹ç™ºãƒ„ãƒ¼ãƒ«ã§ã¯ãªãã€ã‚³ãƒ¼ãƒ‰ã®å“è³ªã¨ãƒãƒ¼ãƒ ã®ç”Ÿç”£æ€§ã‚’å‘ä¸Šã•ã›ã‚‹å¼·åŠ›ãªè³‡ç”£ã§ã™ã€‚é©åˆ‡ã«è¨­è¨ˆã•ã‚ŒãŸå‹ã‚·ã‚¹ãƒ†ãƒ ã¯ã€é•·æœŸçš„ãªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æˆåŠŸã‚’æ”¯ãˆã‚‹é‡è¦ãªåŸºç›¤ã¨ãªã‚Šã¾ã™ã€‚

---

**é–¢é€£è¨˜äº‹:**
- [Next.js 15ã§ãƒ¢ãƒ€ãƒ³ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªã‚µã‚¤ãƒˆã‚’æ§‹ç¯‰ã—ãŸè¨˜éŒ²](/blog/nextjs15-portfolio-development)
- [MDXã§ãƒªãƒƒãƒãªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹æ–¹æ³•](/blog/mdx-content-management)
- [GitHub Actionsè‡ªå‹•ãƒ‡ãƒ—ãƒ­ã‚¤ã®å®Œå…¨ã‚¬ã‚¤ãƒ‰](/blog/github-actions-deployment)
