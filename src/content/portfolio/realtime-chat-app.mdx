---
title: "リアルタイムチャットアプリケーション"
description: "WebSocketとReactを使用したリアルタイム通信が可能なチャットアプリケーション"
date: "2024-01-20"
category: "フルスタック"
technologies: ["React", "TypeScript", "Node.js", "Socket.io", "PostgreSQL", "Tailwind CSS"]
featured: true
github: "https://github.com/example/realtime-chat"
demo: "https://chat-demo.example.com"
image: "/images/portfolio/chat-app.jpg"
---

# リアルタイムチャットアプリケーション

WebSocketを使用したリアルタイム通信機能を持つモダンなチャットアプリケーションです。ユーザー認証、プライベートメッセージ、グループチャット、ファイル共有など、実用的な機能を豊富に実装しています。

## プロジェクト概要

このプロジェクトは、現代的なWebアプリケーションに求められるリアルタイム通信機能を学習・実装することを目的として開発しました。フロントエンドにはReact + TypeScript、バックエンドにはNode.js + Express、リアルタイム通信にはSocket.ioを使用しています。

### 主な機能

- **リアルタイムメッセージング**: WebSocketによる即座なメッセージ配信
- **ユーザー認証**: JWT認証による安全なユーザー管理
- **プライベート・グループチャット**: 1対1およびグループでの会話
- **ファイル共有**: 画像・ドキュメントの送受信機能
- **オンライン状態表示**: ユーザーのオンライン/オフライン状態の表示
- **メッセージ検索**: 過去のメッセージの全文検索機能
- **プッシュ通知**: ブラウザ通知とPWA対応

## 技術的な実装

### フロントエンド

React + TypeScriptをベースとしたSPA（Single Page Application）として構築しました。

```typescript
// WebSocket接続の管理
import { io, Socket } from 'socket.io-client';

class ChatService {
  private socket: Socket;

  constructor() {
    this.socket = io(process.env.REACT_APP_SERVER_URL!);
  }

  connect(token: string) {
    this.socket.auth = { token };
    this.socket.connect();
  }

  sendMessage(roomId: string, message: string) {
    this.socket.emit('message', { roomId, message });
  }

  onMessage(callback: (data: Message) => void) {
    this.socket.on('message', callback);
  }

  joinRoom(roomId: string) {
    this.socket.emit('join-room', roomId);
  }
}
```

状態管理にはZustandを使用し、リアルタイムデータの管理を効率的に行いました：

```typescript
import { create } from 'zustand';

interface ChatStore {
  messages: Message[];
  rooms: Room[];
  activeRoom: string | null;
  addMessage: (message: Message) => void;
  setActiveRoom: (roomId: string) => void;
}

export const useChatStore = create<ChatStore>((set) => ({
  messages: [],
  rooms: [],
  activeRoom: null,
  addMessage: (message) =>
    set((state) => ({
      messages: [...state.messages, message],
    })),
  setActiveRoom: (roomId) =>
    set({ activeRoom: roomId }),
}));
```

### バックエンド

Node.js + Expressをベースとし、Socket.ioでリアルタイム通信を実装しました：

```typescript
import express from 'express';
import { Server } from 'socket.io';
import { authenticateSocket } from './middleware/auth';

const app = express();
const server = createServer(app);
const io = new Server(server, {
  cors: {
    origin: process.env.CLIENT_URL,
    credentials: true,
  },
});

io.use(authenticateSocket);

io.on('connection', (socket) => {
  console.log(`ユーザー ${socket.user.id} が接続しました`);

  socket.on('join-room', async (roomId) => {
    const room = await getRoomById(roomId);
    if (room && await userHasAccess(socket.user.id, roomId)) {
      socket.join(roomId);
      socket.to(roomId).emit('user-joined', {
        userId: socket.user.id,
        username: socket.user.username,
      });
    }
  });

  socket.on('message', async (data) => {
    const { roomId, content } = data;
    
    // メッセージをデータベースに保存
    const message = await saveMessage({
      content,
      roomId,
      senderId: socket.user.id,
    });

    // ルーム内の全ユーザーにメッセージを送信
    io.to(roomId).emit('message', message);
  });

  socket.on('disconnect', () => {
    console.log(`ユーザー ${socket.user.id} が切断しました`);
  });
});
```

### データベース設計

PostgreSQLを使用し、チャット機能に必要なテーブル構造を設計しました：

```sql
-- ユーザーテーブル
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  username VARCHAR(50) UNIQUE NOT NULL,
  email VARCHAR(100) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  avatar_url VARCHAR(255),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ルームテーブル
CREATE TABLE rooms (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  type room_type NOT NULL DEFAULT 'group',
  created_by UUID REFERENCES users(id),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- メッセージテーブル
CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  content TEXT NOT NULL,
  room_id UUID REFERENCES rooms(id) ON DELETE CASCADE,
  sender_id UUID REFERENCES users(id),
  message_type message_type DEFAULT 'text',
  file_url VARCHAR(255),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ルームメンバーテーブル
CREATE TABLE room_members (
  room_id UUID REFERENCES rooms(id) ON DELETE CASCADE,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  role member_role DEFAULT 'member',
  PRIMARY KEY (room_id, user_id)
);
```

## パフォーマンス最適化

### 1. メッセージの仮想化

大量のメッセージを効率的に表示するため、react-windowを使用して仮想化を実装：

```typescript
import { FixedSizeList as List } from 'react-window';

const MessageList: React.FC<{ messages: Message[] }> = ({ messages }) => {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => (
    <div style={style}>
      <MessageItem message={messages[index]} />
    </div>
  );

  return (
    <List
      height={400}
      itemCount={messages.length}
      itemSize={80}
      width="100%"
    >
      {Row}
    </List>
  );
};
```

### 2. 接続の最適化

Socket.ioの接続プールを活用し、効率的な接続管理を実装：

```typescript
// 接続プールの管理
class ConnectionPool {
  private pools = new Map<string, Set<string>>();

  addToPool(roomId: string, socketId: string) {
    if (!this.pools.has(roomId)) {
      this.pools.set(roomId, new Set());
    }
    this.pools.get(roomId)!.add(socketId);
  }

  removeFromPool(roomId: string, socketId: string) {
    this.pools.get(roomId)?.delete(socketId);
    if (this.pools.get(roomId)?.size === 0) {
      this.pools.delete(roomId);
    }
  }

  getRoomSize(roomId: string): number {
    return this.pools.get(roomId)?.size || 0;
  }
}
```

## セキュリティ対策

### 1. XSS対策

ユーザー入力のサニタイズとCSP（Content Security Policy）の実装：

```typescript
import DOMPurify from 'dompurify';

// メッセージのサニタイズ
const sanitizeMessage = (content: string): string => {
  return DOMPurify.sanitize(content, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'code'],
    ALLOWED_ATTR: [],
  });
};
```

### 2. レート制限

express-rate-limitを使用したAPI制限：

```typescript
import rateLimit from 'express-rate-limit';

const messageRateLimit = rateLimit({
  windowMs: 60 * 1000, // 1分
  max: 30, // 最大30メッセージ/分
  message: 'メッセージの送信頻度が高すぎます',
  standardHeaders: true,
  legacyHeaders: false,
});

app.use('/api/messages', messageRateLimit);
```

## 学習した技術・概念

このプロジェクトを通じて習得した主な技術と概念：

### WebSocket通信
- Socket.ioを使用したリアルタイム双方向通信
- ルーム機能による効率的なメッセージ配信
- 接続の管理と切断時の処理

### 状態管理
- Zustandによる軽量で効率的な状態管理
- リアルタイムデータの同期
- 楽観的更新とロールバック機能

### パフォーマンス最適化
- 仮想化による大量データの効率的な表示
- メモ化とコンポーネントの最適化
- 遅延ローディングと分割

### セキュリティ
- JWT認証とリフレッシュトークン
- XSS・CSRF対策
- レート制限とスパム対策

## 今後の改善点

現在検討している機能拡張や改善点：

1. **音声・ビデオ通話機能**: WebRTCを使用した通話機能の追加
2. **モバイルアプリ**: React NativeによるiOS/Androidアプリの開発
3. **メッセージの暗号化**: エンドツーエンド暗号化の実装
4. **AI機能**: 自動翻訳や感情分析の追加
5. **スケーラビリティ**: Redis Clusterによる水平スケーリング

このプロジェクトは、現代的なWebアプリケーション開発における重要な技術を実践的に学ぶことができる包括的な学習プロジェクトとなりました。
